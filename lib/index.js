// Generated by CoffeeScript 1.12.4
var bestChoice, expandPhrase, expandSynonym, expandToken, fixPunctuation, flatten, fs, generate, getPhraseDependencies, grammar, inspect, nearley, parseAndIndex, randomChoice, ref, sortBy, util,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

nearley = require('nearley');

util = require('util');

fs = require('fs');

grammar = require('./grammar');

ref = require('./helpers'), inspect = ref.inspect, sortBy = ref.sortBy, flatten = ref.flatten, randomChoice = ref.randomChoice, fixPunctuation = ref.fixPunctuation;

parseAndIndex = function(grammar_filename) {
  var indexed, input, parsed, parser, phrase_key, phrases, ref1;
  input = fs.readFileSync(grammar_filename, 'utf8').trim();
  parser = new nearley.Parser(grammar.ParserRules, grammar.ParserStart);
  parser.feed(input);
  parsed = parser.results[0];
  indexed = {
    phrases: {},
    synonyms: {}
  };
  parsed.forEach(function(block) {
    if (block.phrase) {
      return indexed.phrases[block.phrase] = block;
    } else if (block.phrase === '') {
      return indexed.phrases.root = block;
    } else if (block.synonym) {
      return indexed.synonyms[block.synonym] = block;
    }
  });
  ref1 = indexed.phrases;
  for (phrase_key in ref1) {
    phrases = ref1[phrase_key];
    phrases.lines.forEach(function(phrase, pi) {
      return phrase.dependencies = getPhraseDependencies(phrase, indexed);
    });
  }
  return indexed;
};

getPhraseDependencies = function(phrase, indexed) {
  var phrase_phrases, phrase_values, sub_dependencies;
  phrase_values = phrase.filter(function(token) {
    return token.value != null;
  }).map(function(token) {
    return token.value;
  });
  phrase_phrases = phrase.filter(function(token) {
    return token.phrase != null;
  }).map(function(token) {
    return token.phrase;
  });
  sub_dependencies = flatten(flatten(phrase_phrases.map(function(phrase_key) {
    return indexed.phrases[phrase_key].lines.map(function(phrase, pi) {
      return getPhraseDependencies(phrase, indexed);
    });
  })));
  return phrase_values.concat(sub_dependencies);
};

bestChoice = function(phrases, values) {
  var available_values, best_count, best_phrases, countDependencies, filtered_phrases, value_counts;
  available_values = Object.keys(values);
  filtered_phrases = phrases.filter(function(phrase) {
    var dependency, i, len, ref1;
    ref1 = phrase.dependencies;
    for (i = 0, len = ref1.length; i < len; i++) {
      dependency = ref1[i];
      if (indexOf.call(available_values, dependency) < 0) {
        return false;
      }
    }
    return true;
  });
  countDependencies = function(phrase) {
    return phrase.dependencies.length;
  };
  value_counts = filtered_phrases.map(countDependencies);
  best_phrases = sortBy(filtered_phrases, countDependencies);
  best_count = countDependencies(best_phrases[0]);
  best_phrases = best_phrases.filter(function(phrase) {
    return countDependencies(phrase) === best_count;
  });
  return randomChoice(best_phrases);
};

expandToken = function(token, indexed, context) {
  var expanded, formatted, formatter, i, item, joiner, len, phrase, phrase_token, ref1, secondary, synonym, synonym_token, this_expanded, value, value_token, word_token;
  expanded = [];
  if (word_token = token.word) {
    expanded.push(word_token);
  } else if (phrase_token = token.phrase) {
    phrase = indexed.phrases[phrase_token];
    this_expanded = expandPhrase(phrase, indexed, context);
    expanded.push(this_expanded);
  } else if (synonym_token = token.synonym) {
    synonym = indexed.synonyms[synonym_token];
    expanded.push(expandSynonym(synonym, indexed, context));
  } else if (value_token = token.value) {
    value = context.values[value_token];
    if (Array.isArray(value) && (joiner = token.joiner)) {
      if (value.length === 1) {
        expanded.push(value[0]);
        return expanded;
      }
      ref1 = value.slice(0, -2);
      for (i = 0, len = ref1.length; i < len; i++) {
        item = ref1[i];
        expanded.push(item);
        expanded.push(expandToken(joiner, indexed, context));
      }
      if (secondary = token.secondary) {
        expanded.push(value.slice(-2)[0]);
        if (token.oxford) {
          expanded.push(expandToken(joiner, indexed, context));
        }
        expanded.push(expandToken(secondary, indexed, context));
      } else {
        expanded.push(value.slice(-2)[0]);
        expanded.push(expandToken(joiner, indexed, context));
      }
      expanded.push(value.slice(-1)[0]);
    } else if (formatter = token.formatter) {
      formatted = context.formatters[formatter](value);
      expanded.push(formatted);
    } else {
      expanded.push(value);
    }
  }
  return expanded;
};

expandPhrase = function(phrase, indexed, context) {
  var expanded, i, len, line, token;
  expanded = [];
  line = bestChoice(phrase.lines, context.values);
  for (i = 0, len = line.length; i < len; i++) {
    token = line[i];
    expanded = expanded.concat(expandToken(token, indexed, context));
  }
  return expanded.join(' ');
};

expandSynonym = function(synonym, indexed, context) {
  var expanded, i, len, line, token;
  expanded = [];
  line = randomChoice(synonym.lines);
  for (i = 0, len = line.length; i < len; i++) {
    token = line[i];
    expanded = expanded.concat(expandToken(token, indexed, context));
  }
  return expanded.join(' ');
};

module.exports = generate = function(grammar_filename, context) {
  var indexed;
  indexed = parseAndIndex(grammar_filename);
  return fixPunctuation(expandPhrase(indexed.phrases.root, indexed, context));
};
