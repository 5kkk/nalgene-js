#!/usr/bin/env node
// Generated by CoffeeScript 1.12.4
var argv, asSentence, context, expandPhrase, expandPhrases, expandTokens, filename, flatten, fs, generate, grammar, k, minimist, parse, randomChoice, ref, splitToken, v,
  slice = [].slice;

fs = require('fs');

minimist = require('minimist');

ref = require('./helpers'), randomChoice = ref.randomChoice, flatten = ref.flatten, splitToken = ref.splitToken, asSentence = ref.asSentence;

parse = require('./parse');

module.exports = generate = function(root, context, entry_key, options) {
  var best_phrases, entry, good_phrases, i, inContext, len, notInContext, numInContext, numNotInContext, num_in_best, phrase, phrases, skip_duplicates;
  if (context == null) {
    context = {};
  }
  if (entry_key == null) {
    entry_key = '%';
  }
  if (options == null) {
    options = {};
  }
  skip_duplicates = options.skip_duplicates;
  entry = root.get(entry_key);
  if (entry == null) {
    throw new Error('No such phrase on root: ' + entry_key);
  }
  phrases = expandPhrases(entry, root);
  notInContext = function(token) {
    return token.match(/^\$/) && (context[token] == null);
  };
  numNotInContext = function(tokens) {
    var i, len, n, ref1, token, used;
    n = 0;
    used = {};
    ref1 = flatten(tokens.map(splitToken));
    for (i = 0, len = ref1.length; i < len; i++) {
      token = ref1[i];
      if (notInContext(token)) {
        n += 1;
      } else if (inContext(token) && skip_duplicates) {
        if (used[token]) {
          n += 1;
        } else {
          used[token] = true;
        }
      }
    }
    return n;
  };
  inContext = function(token) {
    return token.match(/^\$/) && (context[token] != null);
  };
  numInContext = function(tokens) {
    var i, len, n, ref1, token, used;
    n = 0;
    used = {};
    ref1 = flatten(tokens.map(splitToken));
    for (i = 0, len = ref1.length; i < len; i++) {
      token = ref1[i];
      if (inContext(token)) {
        if (!used[token] || !skip_duplicates) {
          used[token] = true;
          n += 1;
        }
      }
    }
    return n;
  };
  good_phrases = phrases.filter(function(tokens) {
    return numNotInContext(tokens) === 0;
  });
  if (good_phrases.length === 0) {
    throw new Error('No viable phrases for entry ' + entry_key + ' with context: ' + JSON.stringify(context));
  }
  good_phrases.sort(function(a, b) {
    return numInContext(b) - numInContext(a);
  });
  num_in_best = numInContext(good_phrases[0]);
  best_phrases = [];
  for (i = 0, len = good_phrases.length; i < len; i++) {
    phrase = good_phrases[i];
    if (numInContext(phrase) === num_in_best) {
      best_phrases.push(phrase);
    } else {
      break;
    }
  }
  phrase = randomChoice(best_phrases);
  return asSentence(expandTokens(phrase, root, context));
};

expandPhrases = function(phrase, root) {
  return flatten(phrase.allLeaves().map(function(leaf) {
    return expandPhrase(leaf.key, root);
  }));
};

expandPhrase = function(key, root) {
  var e, expansion, expansions, i, j, l, len, len1, len2, len3, m, new_expansions, ref1, sub_phrase, token, tokens;
  expansions = [[]];
  tokens = key.split(' ');
  for (i = 0, len = tokens.length; i < len; i++) {
    token = tokens[i];
    if (token.match(/^%/)) {
      new_expansions = [];
      token = token.split('|')[0];
      sub_phrase = root.get(token);
      if (!sub_phrase) {
        throw new Error('No such phrase on root: ' + token);
      }
      ref1 = expandPhrases(sub_phrase, root);
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        e = ref1[j];
        for (l = 0, len2 = expansions.length; l < len2; l++) {
          expansion = expansions[l];
          new_expansions.push(expansion.concat(e));
        }
      }
      expansions = new_expansions;
    } else {
      for (m = 0, len3 = expansions.length; m < len3; m++) {
        expansion = expansions[m];
        expansion.push(token);
      }
    }
  }
  return expansions;
};

expandTokens = function(tokens, root, context) {
  var chosen_synonym, chosen_synonyms, expanded, g, given, i, j, len, len1, pruned_synonym, ref1, sub_phrase, sub_tokens, synonym, synonym_tokens, token;
  expanded = [];
  chosen_synonyms = {};
  for (i = 0, len = tokens.length; i < len; i++) {
    token = tokens[i];
    if (token.match(/^\$/)) {
      expanded.push(context[token]);
    } else if (token.match(/^~/)) {
      if (token.match(/\?$/)) {
        if (Math.random() < 0.5) {
          continue;
        } else {
          token = token.slice(0, -1);
        }
      }
      synonym = root.get(token);
      if (!synonym) {
        throw new Error('No such synonym on root: ' + token);
      }
      pruned_synonym = synonym.prune(chosen_synonyms[token]);
      if (pruned_synonym.children.length === 0) {
        pruned_synonym = synonym;
        delete chosen_synonyms[token];
      }
      chosen_synonym = pruned_synonym.randomLeaf().key;
      chosen_synonyms[token] || (chosen_synonyms[token] = []);
      chosen_synonyms[token].push(chosen_synonym);
      synonym_tokens = chosen_synonym.split(' ');
      expanded = expanded.concat(expandTokens(synonym_tokens, root, context));
    } else if (token.match(/^#/)) {
      ref1 = token.split('|'), token = ref1[0], given = 2 <= ref1.length ? slice.call(ref1, 1) : [];
      sub_phrase = root.get(token);
      if (sub_phrase == null) {
        throw new Error('No such hash on root: ' + token);
      }
      if (!given.length) {
        throw new Error('No values given for hash: ' + token);
      }
      for (j = 0, len1 = given.length; j < len1; j++) {
        g = given[j];
        if (g.match(/^\$/)) {
          sub_phrase = sub_phrase.get(context[g]);
        } else {
          sub_phrase = sub_phrase.get(g);
        }
        if (sub_phrase == null) {
          throw new Error('No such value on hash: ' + token + '|' + given.map(function(g) {
            return context[g];
          }).join('|'));
        }
      }
      sub_tokens = sub_phrase.randomLeaf().key.split(' ');
      expanded = expanded.concat(expandTokens(sub_tokens, root, context));
    } else {
      expanded.push(token);
    }
  }
  return expanded;
};

module.exports.fromPlainString = function(string, context) {
  var root;
  root = parse.fromObject({
    '%': string
  });
  return generate(root, context);
};

if (require.main === module) {
  argv = minimist(process.argv.slice(2));
  parse = require('./parse');
  filename = process.argv[2];
  if (filename == null) {
    console.log("Usage: nalgene [file.nlg] (--key=value...)");
    process.exit();
  }
  grammar = parse(fs.readFileSync(filename, 'utf8'));
  context = {};
  for (k in argv) {
    v = argv[k];
    context['$' + k] = v;
  }
  console.log(generate(grammar, context));
}
