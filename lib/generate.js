// Generated by CoffeeScript 1.12.4
var asSentence, expandPhrase, expandPhrases, expandTokens, filterPhrases, flatten, generate, randomChoice, ref, splitToken,
  slice = [].slice;

ref = require('./helpers'), randomChoice = ref.randomChoice, flatten = ref.flatten, splitToken = ref.splitToken, asSentence = ref.asSentence;

module.exports = generate = function(root, context, entry_key) {
  var good_phrases, phrases;
  if (context == null) {
    context = {};
  }
  if (entry_key == null) {
    entry_key = '%';
  }
  phrases = expandPhrases(root.get(entry_key), root);
  good_phrases = filterPhrases(phrases, context);
  return asSentence(expandTokens(good_phrases[0], root, context));
};

expandPhrases = function(phrase, root) {
  return flatten(phrase.allLeaves().map(function(leaf) {
    return expandPhrase(leaf.key, root);
  }));
};

expandPhrase = function(key, root) {
  var e, expansion, expansions, i, j, k, l, len, len1, len2, len3, new_expansions, ref1, token, tokens;
  expansions = [[]];
  tokens = key.split(' ');
  for (i = 0, len = tokens.length; i < len; i++) {
    token = tokens[i];
    if (token.match(/^%/)) {
      new_expansions = [];
      token = token.split('|')[0];
      ref1 = expandPhrases(root.get(token), root);
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        e = ref1[j];
        for (k = 0, len2 = expansions.length; k < len2; k++) {
          expansion = expansions[k];
          new_expansions.push(expansion.concat(e));
        }
      }
      expansions = new_expansions;
    } else {
      for (l = 0, len3 = expansions.length; l < len3; l++) {
        expansion = expansions[l];
        expansion.push(token);
      }
    }
  }
  return expansions;
};

filterPhrases = function(phrases, context) {
  var notInContext;
  notInContext = function(token) {
    if (token.match(/^\$/)) {
      return context[token] == null;
    } else {
      return false;
    }
  };
  return phrases.filter(function(tokens) {
    var f;
    f = flatten(tokens.map(splitToken));
    return f.filter(notInContext).length === 0;
  });
};

expandTokens = function(tokens, root, context) {
  var expanded, g, given, i, j, len, len1, ref1, sub_phrase, sub_tokens, synonyms, token;
  expanded = [];
  for (i = 0, len = tokens.length; i < len; i++) {
    token = tokens[i];
    if (token.match(/^\$/)) {
      expanded.push(context[token]);
    } else if (token.match(/^~/)) {
      synonyms = root.get(token);
      expanded.push(synonyms.randomLeaf().key);
    } else if (token.match(/^#/)) {
      ref1 = token.split('|'), token = ref1[0], given = 2 <= ref1.length ? slice.call(ref1, 1) : [];
      sub_phrase = root.get(token);
      if (given.length) {
        for (j = 0, len1 = given.length; j < len1; j++) {
          g = given[j];
          if (g.match(/^\$/)) {
            sub_phrase = sub_phrase.get(context[g]);
          } else {
            sub_phrase = sub_phrase.get(g);
          }
        }
      }
      sub_tokens = sub_phrase.randomLeaf().key.split(' ');
      expanded = expanded.concat(expandTokens(sub_tokens, root, context));
    } else {
      expanded.push(token);
    }
  }
  return expanded;
};
