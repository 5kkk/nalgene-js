// Generated by CoffeeScript 1.12.4
var asSentence, expandPhrase, expandPhrases, expandTokens, flatten, generate, randomChoice, ref, splitToken,
  slice = [].slice;

ref = require('./helpers'), randomChoice = ref.randomChoice, flatten = ref.flatten, splitToken = ref.splitToken, asSentence = ref.asSentence;

module.exports = generate = function(root, context, entry_key, options) {
  var best_phrases, entry, good_phrases, i, inContext, len, notInContext, numInContext, numNotInContext, num_in_best, phrase, phrases, skip_duplicates;
  if (context == null) {
    context = {};
  }
  if (entry_key == null) {
    entry_key = '%';
  }
  if (options == null) {
    options = {};
  }
  skip_duplicates = options.skip_duplicates;
  entry = root.get(entry_key);
  if (entry == null) {
    throw new Error('No such phrase on root: ' + entry_key);
  }
  phrases = expandPhrases(entry, root);
  notInContext = function(token) {
    return token.match(/^\$/) && (context[token] == null);
  };
  numNotInContext = function(tokens) {
    var i, len, n, ref1, token, used;
    n = 0;
    used = {};
    ref1 = flatten(tokens.map(splitToken));
    for (i = 0, len = ref1.length; i < len; i++) {
      token = ref1[i];
      if (notInContext(token)) {
        n += 1;
      } else if (inContext(token) && skip_duplicates) {
        if (used[token]) {
          n += 1;
        } else {
          used[token] = true;
        }
      }
    }
    return n;
  };
  inContext = function(token) {
    return token.match(/^\$/) && (context[token] != null);
  };
  numInContext = function(tokens) {
    var i, len, n, ref1, token, used;
    n = 0;
    used = {};
    ref1 = flatten(tokens.map(splitToken));
    for (i = 0, len = ref1.length; i < len; i++) {
      token = ref1[i];
      if (inContext(token)) {
        if (!used[token] || !skip_duplicates) {
          used[token] = true;
          n += 1;
        }
      }
    }
    return n;
  };
  good_phrases = phrases.filter(function(tokens) {
    return numNotInContext(tokens) === 0;
  });
  if (good_phrases.length === 0) {
    throw new Error('No viable phrases for entry ' + entry_key + ' with context: ' + JSON.stringify(context));
  }
  good_phrases.sort(function(a, b) {
    return numInContext(b) - numInContext(a);
  });
  num_in_best = numInContext(good_phrases[0]);
  best_phrases = [];
  for (i = 0, len = good_phrases.length; i < len; i++) {
    phrase = good_phrases[i];
    if (numInContext(phrase) === num_in_best) {
      best_phrases.push(phrase);
    } else {
      break;
    }
  }
  phrase = randomChoice(best_phrases);
  return asSentence(expandTokens(phrase, root, context));
};

expandPhrases = function(phrase, root) {
  return flatten(phrase.allLeaves().map(function(leaf) {
    return expandPhrase(leaf.key, root);
  }));
};

expandPhrase = function(key, root) {
  var e, expansion, expansions, i, j, k, l, len, len1, len2, len3, new_expansions, ref1, sub_phrase, token, tokens;
  expansions = [[]];
  tokens = key.split(' ');
  for (i = 0, len = tokens.length; i < len; i++) {
    token = tokens[i];
    if (token.match(/^%/)) {
      new_expansions = [];
      token = token.split('|')[0];
      sub_phrase = root.get(token);
      if (!sub_phrase) {
        throw new Error('No such phrase on root: ' + token);
      }
      ref1 = expandPhrases(sub_phrase, root);
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        e = ref1[j];
        for (k = 0, len2 = expansions.length; k < len2; k++) {
          expansion = expansions[k];
          new_expansions.push(expansion.concat(e));
        }
      }
      expansions = new_expansions;
    } else {
      for (l = 0, len3 = expansions.length; l < len3; l++) {
        expansion = expansions[l];
        expansion.push(token);
      }
    }
  }
  return expansions;
};

expandTokens = function(tokens, root, context) {
  var expanded, g, given, i, j, len, len1, ref1, sub_phrase, sub_tokens, synonym, synonym_tokens, token;
  expanded = [];
  for (i = 0, len = tokens.length; i < len; i++) {
    token = tokens[i];
    if (token.match(/^\$/)) {
      expanded.push(context[token]);
    } else if (token.match(/^~/)) {
      if (token.match(/\?$/)) {
        if (Math.random() < 0.5) {
          continue;
        } else {
          token = token.slice(0, -1);
        }
      }
      synonym = root.get(token);
      if (!synonym) {
        throw new Error('No such synonym on root: ' + token);
      }
      synonym_tokens = synonym.randomLeaf().key.split(' ');
      expanded = expanded.concat(expandTokens(synonym_tokens, root, context));
    } else if (token.match(/^#/)) {
      ref1 = token.split('|'), token = ref1[0], given = 2 <= ref1.length ? slice.call(ref1, 1) : [];
      sub_phrase = root.get(token);
      if (sub_phrase == null) {
        throw new Error('No such hash on root: ' + token);
      }
      if (!given.length) {
        throw new Error('No values given for hash: ' + token);
      }
      for (j = 0, len1 = given.length; j < len1; j++) {
        g = given[j];
        if (g.match(/^\$/)) {
          sub_phrase = sub_phrase.get(context[g]);
        } else {
          sub_phrase = sub_phrase.get(g);
        }
        if (sub_phrase == null) {
          throw new Error('No such value on hash: ' + token + '|' + given.map(function(g) {
            return context[g];
          }).join('|'));
        }
      }
      sub_tokens = sub_phrase.randomLeaf().key.split(' ');
      expanded = expanded.concat(expandTokens(sub_tokens, root, context));
    } else {
      expanded.push(token);
    }
  }
  return expanded;
};
