#!/usr/bin/env node
// Generated by CoffeeScript 1.12.4
var VERBOSE, argv, asSentence, bestMatch, context, contextAsString, expandTokens, filename, flatten, fs, generate, grammar, group, k, listKeys, listValues, minimist, parse, randomChoice, ref, scoreKey, splitToken, v,
  slice = [].slice;

fs = require('fs');

minimist = require('minimist');

ref = require('./helpers'), randomChoice = ref.randomChoice, flatten = ref.flatten, splitToken = ref.splitToken, asSentence = ref.asSentence;

parse = require('./parse');

VERBOSE = true;

group = function(list, group_by) {
  var a, grouped, j, ref1;
  if (group_by == null) {
    group_by = 2;
  }
  grouped = [];
  for (a = j = 0, ref1 = Math.floor(list.length / group_by); 0 <= ref1 ? j < ref1 : j > ref1; a = 0 <= ref1 ? ++j : --j) {
    grouped.push(list.slice(a * group_by, (a + 1) * group_by));
  }
  return grouped;
};

listKeys = function(list) {
  var j, l, len, results;
  results = [];
  for (j = 0, len = list.length; j < len; j++) {
    l = list[j];
    results.push(l[0]);
  }
  return results;
};

listValues = function(list) {
  var j, l, len, results;
  results = [];
  for (j = 0, len = list.length; j < len; j++) {
    l = list[j];
    results.push(l[1]);
  }
  return results;
};

bestMatch = function(child_keys, context) {
  var child_key, context_keys, j, len, score;
  for (j = 0, len = child_keys.length; j < len; j++) {
    child_key = child_keys[j];
    context_keys = listKeys(group(context));
    score = scoreKey(child_key, context_keys);
    if (score === 0) {
      return [child_key, listValues(group(context))];
    }
  }
  return [null, null];
};

scoreKey = function(child_key, context_keys) {
  var cc, child_phrases, child_tokens, ci;
  if (VERBOSE) {
    console.log('[scoreKey]', child_key, context_keys);
  }
  child_tokens = child_key.split(' ');
  child_phrases = child_tokens.filter(function(t) {
    var ref1;
    return (ref1 = t[0]) === '%' || ref1 === '$';
  });
  while (context_keys.length) {
    cc = context_keys.shift();
    ci = child_phrases.indexOf(cc);
    if (ci === -1) {
      return -1;
    } else {
      child_phrases.splice(ci, 1);
    }
  }
  return child_phrases.length;
};

contextAsString = function(l) {
  if (typeof l === 'string') {
    return l;
  } else {
    return group(l).map(function(g) {
      return g.map(contextAsString).join(': ');
    }).join(', ');
  }
};

module.exports = generate = function(root, entry_key, context, options) {
  var best_match, child, child_keys, contexts, entry, expandable, expanded, i, j, len, ref1, ref2, sub_context, synonym, token;
  if (entry_key == null) {
    entry_key = '%';
  }
  if (context == null) {
    context = {};
  }
  if (options == null) {
    options = {};
  }
  if (VERBOSE) {
    console.log('\n[generate]', 'entry =', entry_key, 'context =', context);
  }
  entry = root.get(entry_key);
  if (entry == null) {
    throw new Error('No such phrase on root: ' + entry_key);
  }
  child_keys = (function() {
    var j, len, ref1, results;
    ref1 = entry.children;
    results = [];
    for (j = 0, len = ref1.length; j < len; j++) {
      child = ref1[j];
      results.push(child.key);
    }
    return results;
  })();
  ref1 = bestMatch(child_keys, context), best_match = ref1[0], contexts = ref1[1];
  if (best_match == null) {
    throw new Error("No best match for " + entry_key + " with context " + (contextAsString(context)));
    process.exit(0);
  }
  expanded = [];
  expandable = best_match.split(' ').filter(function(t) {
    var ref2;
    return (ref2 = t[0]) === '%' || ref2 === '$';
  });
  ref2 = best_match.split(' ');
  for (j = 0, len = ref2.length; j < len; j++) {
    token = ref2[j];
    i = expandable.indexOf(token);
    if (i > -1) {
      expandable[i] = 'EXPANDED';
      sub_context = contexts[i];
      if (token[0] === '%') {
        expanded.push(generate(root, token, sub_context, options));
      } else {
        expanded.push(sub_context);
      }
    } else {
      if (token[0] === '~') {
        if (token.match(/\?$/)) {
          if (Math.random() < 0.5) {
            continue;
          } else {
            token = token.slice(0, -1);
          }
        }
        synonym = root.get(token);
        expanded.push(synonym.randomLeaf().key);
      } else {
        expanded.push(token);
      }
    }
  }
  return expanded;
};

expandTokens = function(tokens, root, context) {
  var chosen_synonym, chosen_synonyms, expanded, g, given, j, len, len1, m, pruned_synonym, ref1, sub_phrase, sub_tokens, synonym, synonym_tokens, token;
  if (VERBOSE) {
    console.log('[expandTokens]', tokens);
  }
  expanded = [];
  chosen_synonyms = {};
  for (j = 0, len = tokens.length; j < len; j++) {
    token = tokens[j];
    if (token.match(/^\$/)) {
      expanded.push(context[token]);
    } else if (token.match(/^~/)) {
      if (token.match(/\?$/)) {
        if (Math.random() < 0.5) {
          continue;
        } else {
          token = token.slice(0, -1);
        }
      }
      synonym = root.get(token);
      if (!synonym) {
        throw new Error('No such synonym on root: ' + token);
      }
      pruned_synonym = synonym.prune(chosen_synonyms[token]);
      if (pruned_synonym.children.length === 0) {
        pruned_synonym = synonym;
        delete chosen_synonyms[token];
      }
      chosen_synonym = pruned_synonym.randomLeaf().key;
      chosen_synonyms[token] || (chosen_synonyms[token] = []);
      chosen_synonyms[token].push(chosen_synonym);
      synonym_tokens = chosen_synonym.split(' ');
      expanded = expanded.concat(expandTokens(synonym_tokens, root, context));
    } else if (token.match(/^#/)) {
      ref1 = token.split('|'), token = ref1[0], given = 2 <= ref1.length ? slice.call(ref1, 1) : [];
      sub_phrase = root.get(token);
      if (sub_phrase == null) {
        throw new Error('No such hash on root: ' + token);
      }
      if (!given.length) {
        throw new Error('No values given for hash: ' + token);
      }
      for (m = 0, len1 = given.length; m < len1; m++) {
        g = given[m];
        if (g.match(/^\$/)) {
          sub_phrase = sub_phrase.get(context[g]);
        } else {
          sub_phrase = sub_phrase.get(g);
        }
        if (sub_phrase == null) {
          throw new Error('No such value on hash: ' + token + '|' + given.map(function(g) {
            return context[g];
          }).join('|'));
        }
      }
      sub_tokens = sub_phrase.randomLeaf().key.split(' ');
      expanded = expanded.concat(expandTokens(sub_tokens, root, context));
    } else {
      expanded.push(token);
    }
  }
  return expanded;
};

module.exports.fromPlainString = function(string, context) {
  var root;
  root = parse.fromObject({
    '%': string
  });
  return generate(root, context);
};

if (require.main === module) {
  argv = minimist(process.argv.slice(2));
  parse = require('./parse');
  filename = process.argv[2];
  if (filename == null) {
    console.log("Usage: nalgene [file.nlg] (--key=value...)");
    process.exit();
  }
  grammar = parse(fs.readFileSync(filename, 'utf8'));
  context = {};
  for (k in argv) {
    v = argv[k];
    context['$' + k] = v;
  }
  console.log(generate(grammar, context));
}
